{"pages":[{"title":"关于我","permalink":"http://keyin.me/about/index.html","text":"一枚iOS程序猿，爱折腾技术，喜欢： Objective-C Java C++ 同时我也喜欢： 造轮子 鼓捣一些网络协议 思考设计模式 我的联系方式： Github： Droid43 Mail: &#x7a;&#x65;&#110;&#103;&#103;&#101;&#x6e;&#x2e;&#99;&#x63;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;"}],"posts":[{"title":"一种自定义循环滑动组件的设计","permalink":"http://keyin.me/2017/03/16/loop-scrollview/","text":"自定义循环滑动组件，通过UIView采用了复用机制来显示，UIPanGestureRecognizer来实现手势的识别，同时通过CADisplayLink来完成具体的动画。可以设定滚动方向，是否连续滚动，是否自动滚动，以及各个滚动状态的回调等 ZGLoopScrollView可以通过xib文件或者代码初始化， 前言最初实现循环滑动组件的时候，是通过使用的UIScrollView，在delegate里面改变View的位置来实现的，但是发现这样做无法再使用UIScrollView的delegate委托了，于是乎自己动手用UIView和UIPanGestureRecognizer撸了一个，顺便仿照了一下UITableView的复用机制。先上效果图： 原理模型循环滑动示图显示模型如下： 显示的部分由两部分组成：可视区和左右两侧的待显示区 所需示图个数为：可视区包含View个数＋2 当触发滑动事件时，一侧的待显示区的View被移除，可视区变为待显示区，另一侧将会创建新的待显示区View，如下图所示： 轮播示图在滚动显示时有可分为部分： 可视区和待显示区示图的确定及其复用方式 在交互过程中滑动时，可视区和待显示区示图内容和位置的确定 交互结束后的动画事件（减速，回弹，分页滑动等） 示图的加载及复用机制循环滚动组件中的示图＝可视区示图＋两边待显示区的示图 使用NSMutableDictionary来存储循环滚动组件中显示的示图，NSMutableSet来管理复用的示图 使用scrollOffset来记录当前滚动的位移，以计算需要加载的示图 使用dataSource来实现数据源委托 1234@property (nonatomic, strong) NSMutableDictionary *itemViews;@property (nonatomic, strong) NSMutableSet *itemViewPool;@property (nonatomic, assign) CGFloat scrollOffset;@property (nonatomic, weak) IBOutlet __nullable id&lt;ZGLoopScrollViewDataSource&gt; dataSource; 每当scrollOffset变化时 计算当前需要显示哪些示图，根据scrollOffset计算出需要显示的示图序号； 将itemViews中不需要的示图移除并存储的itemViewPool当中 获取itemViews中不存在但是需要显示的示图，先从集合检查是否有被移除的示图，有就从itemViewPool取出返回，否则从dataSource中初始化对应位置的示图，同时使用示图序号作为key值添加到itemViews当中； 根据scrollOffset调整itemViews中各个示图的位置，可以使用UIView的transform来方便的完成平移操作； 到这里，遍已经完成了示图显示初始化的核心操作，后面的滑动手势以及动画效果，都是基于scrollOffset的改变来完成的。 根据滑动事件调整位置滑动工过程中所做的工作主要是 滑动开始时更改一些状态的标志 12345678case UIGestureRecognizerStateBegan:&#123; _draging = YES;_bouncing = NO;_decelerating = NO;_scrolling = NO;_lastTranslation = - _vertical? [panGesture translationInView:self].y: [panGesture translationInView:self].x;&#125; 以免在滑动过程中对示图位置做的修改时，与未完成的动画事件所做的修改冲突，导致位置错乱。 滑动状态改变时 记录每次手势事件触发时的位移大小和方向，然后根据是否循环滚动(loopEnabled)，是否边界回弹 (loopEnabled)来修改scrollOffset的大小，最后从新加载需要显示的示图，和调整位置。 滑动手势结束时 纪录当前滑动手势速度大小和方向，然后启动滑动动画，做减速处理等动画操作。 滑动动画事件滑动手势结束后的减速、回弹等动画都是采用CADisplayLink，根据屏幕刷新频率来不断的从新加载需要显示的示图，调整位置123456-(void)startScrollAnimation&#123; if(_displayLink == nil)&#123; self.displayLink=[CADisplayLink displayLinkWithTarget:self selector:@selector(scrollAnimation)]; [_displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; &#125;&#125; 其中减速动画，是根据手势结束时记录的速度，结合固定的动画时间来做匀减速直线运动； 回弹效果动画，是根据当前和最后的scrollOffset差值作为位移距离，结合固定的动画时间来做匀加速直线运动。 运动位置都是一些基本的物理知识做的计算，就不再用代码一一罗列，有兴趣可以下载源码查看 。 到此，循环滑动组件的设计所包含的最基本内容已经完成。 其他内容 水平与垂直滚动两种模式，通过vertical属性确定。在两种模式下，scrollOffset，手势的位移、速度，动画效果，以及示图的位置计算分别与之对应； 为了不因clipsToBounds属性的设置导致待显示区的示图被显示出来，组件内部添加了容器UIView contentView，重写了layoutSubviews方法，对contentView的frame做出了修正； 仿照UIScrollView，通过delegate实现各个滑动状态的委托； 通过NSTimer实现自动滚动 小结本文主要分析了循环滚动示图的实现过程，同时通过UIPanGestureRecognizer和CADisplayLink，采用UIView复用的方式对其进行了实践。 具体源码和使用范例可以在我的GitHub主页下载 下载Demo查看"},{"title":"alihotfix_learn","permalink":"http://keyin.me/2017/03/14/alihotfix-learn/","text":"关于AliHotFix热修复的学习总结 问题背景 原生应用打包在App Store发布苹果公司的审核周期过长(大概一到三天，时间比较看人品)，在应用由于某些原因出现影响用户使用的重大bug时，无法及时解决线上问题。 AliHotFix原理简述AliHotFix通过JavaScript修复iOS 其原理与JSPath的实现原理一致，都是依赖依赖系统javascriptcore,framework系统框架通过JavaScript语言使用Objective-C的原生代码，使脚本语言可以在App中执行。 关于OC的动态特性 123TestClass *test = [[TestClass alloc] init];test.name = @&quot;&quot;;[test medoth];"},{"title":"Article Template","permalink":"http://keyin.me/2017/03/14/article-template/","text":"hexo框架下使用markdown写作大纲的通用模版 关于✕✕✕问题的解决与分析一. 问题简述与相关原理 问题描述 相关背景知识 二. 解决方案与流程 问题解决思路 思维导图 三. 方案实现 流程图 具体实现 源码地址Demo 四. 总结"},{"title":"ALAssetCocoaHTTPServer","permalink":"http://keyin.me/2017/03/10/README/","text":"基于CocoaHTTPServer iOS HTTP 服务器的相册资源共享服务框架 说明及注意事项 FFmpeg Version 2.8 FFmpeg 仅编译部必需的功能 FFmpeg 需要导入的动态库libz.tbd,libiconv.tbd,libbz2.tbd iOS 10 + 需要添加相册访问权限，否则无法访问相册资源 iOS 9 + 使用HTTP请求需要在Info.plist中添加 NSAllowsArbitraryLoads 为YES 若需要媒体共享服务被访问期间可后台运行，需要在 Info.plist中添加 Required background modes 添加条目选择App plays audio or streams audio/video using AirPlay 必需在同一局域网下方可访问 如何使用1. CocoaPods集成12345platform :ios, '7.0'target 'ALAssetCocoaHTTPServerDemo' dopod 'ALAssetCocoaHTTPServer',:svn =&gt;\"http://172.20.3.159/svn/Android/App/ScreensInteract3/sourcecode/trunk/IOS-901/MultiScreenFramework/ALAssetCocoaHTTPServer/\", :tag =&gt;\"0.0.2\"end 2. 使用范例12345678910HTTPServer *httpServer = [[HTTPServer alloc] init];[httpServer setType:@\"_http._tcp.\"];[httpServer setDocumentRoot:NSHomeDirectory()];[httpServer setPort:12345];NSError *error;if([httpServer start:&amp;error]) NSLog(@\"Started HTTP Server on http://%@:%hu\", [httpServer domain], [httpServer listeningPort]);else NSLog(@\"Error starting HTTP Server: %@\", error); 3. 打开调试打印12345678910#import \"DDTTYLogger.h\"@interface AppDelegate ()@end@implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [DDLog addLogger:[DDTTYLogger sharedInstance]]; [[DDTTYLogger sharedInstance] setColorsEnabled:YES];&#125;@end 4. 请求url样式若当前IP为192.168.1.100 tag:0.0.2版 系统视频资源url：assets-library://asset/asset.mp4?id=8F308A6B-EE6F-471B-B2CD-DB6CB625C9BE&amp;ext=mp4 0.0.1版 url： http://192.168.1.100:12345/8F308A6B-EE6F-471B-B2CD-DB6CB625C9BE.mp4不可用 默认访问 url为：http://192.168.1.100:12345/8F308A6B-EE6F-471B-B2CD-DB6CB625C9BE.mp4.m3u8 若播放器支持，可根据当前网络带宽多流适配，访问合适分辨率的视频资源 若访问 url为：http://192.168.1.100:12345/8F308A6B-EE6F-471B-B2CD-DB6CB625C9BE.mp4.type.m3u8。 type表示画质的高低可为：low、 mid、high、super，其中low表示画质最差，所需网络带宽最小，压缩程度最大；super表示原有画质，所需网络带宽最大，不进行压缩处理。 图片url创建方式不变 tag:0.0.1版 系统视频资源url：assets-library://asset/asset.mp4?id=8F308A6B-EE6F-471B-B2CD-DB6CB625C9BE&amp;ext=mp4则访问 url为：http://192.168.1.100:12345/8F308A6B-EE6F-471B-B2CD-DB6CB625C9BE.mp4 系统图片资源url：assets-library://asset/asset.PNG?id=4091A22F-3BA9-42F6-85C6-7B0992A75457&amp;ext=PNG则访问url为：http://192.168.1.100:12345/4091A22F-3BA9-42F6-85C6-7B0992A75457.PNG 实现原理1.图片文件请求 图片文件的获取比较简单，直接通过url定位到系统相册资源后通过调用系统接口获取对应数据 2.视频请求流程简介12345678910st=&gt;start: 客户端io=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 1234567891011sequenceDiagram客户端-&gt;CocoaHTTPServer: 访问m3u8文件 CocoaHTTPServer-&gt;m3u8生成器: 请求m3u8文件note right of m3u8生成器:根据请求媒体\\n文件及分片长度\\n生成m3u8文件m3u8生成器--&gt;CocoaHTTPServer:返回生成文件CocoaHTTPServer--&gt;客户端:返回m3u8文件客户端-&gt;CocoaHTTPServer: 请求ts文件 CocoaHTTPServer-&gt;ts文件管理: 请ts视频文件note right of ts文件管理:获取本地沙盒目录下的\\nts缓存文件或根据请求\\nurl临时转码，切片，\\n封装而生成，同时删除\\n失效的ts临时文件ts文件管理--&gt;CocoaHTTPServer:返回获取文件CocoaHTTPServer--&gt;客户端:返回ts视频文件 iOS文件只能访问沙盒路径内的资源，在通过将http请求相册视频资源文件时，可通过系统接口来获取； 为了解决系统部分mov格式视频部分平台播放器解码不支持的问题，在获取资源文件后将原文件转码为了mp4格式； 为了使转码后的文件不占用太多的内存空间，转码时根据请求文件的大小，只将部分请求的文件转换为mp4格式； 获取m3u8文件 通过url定位到系统相册资源 根据资源文件时长计算出分片策略 文件信息，分片时长创建ts切片对应url 生成相应m3u8文件 获取ts切片资源 播放器解析m3u8文件解析获取ts分片视频资源url 生成ts切片 根据url获取视频文件信息，切片时长和序列号 通过系统接口获取到对应时间段的视频切片数据 若为mov格式，则将其转换为mp4格式 使用FFmpeg将mp4格式切片数据转换为ts封装格式"}]}